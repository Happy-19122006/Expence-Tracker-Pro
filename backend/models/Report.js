const mongoose = require('mongoose');

const reportSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User is required']
  },
  period: {
    type: String,
    required: [true, 'Report period is required'],
    enum: ['daily', 'weekly', 'monthly', 'yearly', 'custom']
  },
  startDate: {
    type: Date,
    required: [true, 'Start date is required']
  },
  endDate: {
    type: Date,
    required: [true, 'End date is required']
  },
  summary: {
    totalIncome: {
      type: Number,
      default: 0,
      min: 0
    },
    totalExpense: {
      type: Number,
      default: 0,
      min: 0
    },
    netBalance: {
      type: Number,
      default: 0
    },
    transactionCount: {
      type: Number,
      default: 0,
      min: 0
    },
    averageIncome: {
      type: Number,
      default: 0,
      min: 0
    },
    averageExpense: {
      type: Number,
      default: 0,
      min: 0
    }
  },
  categoryBreakdown: [{
    category: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Category',
      required: true
    },
    amount: {
      type: Number,
      required: true,
      min: 0
    },
    count: {
      type: Number,
      required: true,
      min: 0
    },
    percentage: {
      type: Number,
      min: 0,
      max: 100
    }
  }],
  topTransactions: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Transaction'
  }],
  insights: [{
    type: {
      type: String,
      enum: ['spending_pattern', 'income_trend', 'category_alert', 'budget_warning', 'savings_goal'],
      required: true
    },
    title: {
      type: String,
      required: true
    },
    description: {
      type: String,
      required: true
    },
    severity: {
      type: String,
      enum: ['info', 'warning', 'critical'],
      default: 'info'
    },
    data: mongoose.Schema.Types.Mixed
  }],
  generatedAt: {
    type: Date,
    default: Date.now
  },
  isAutoGenerated: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for savings rate
reportSchema.virtual('savingsRate').get(function() {
  if (this.summary.totalIncome === 0) return 0;
  return ((this.summary.totalIncome - this.summary.totalExpense) / this.summary.totalIncome) * 100;
});

// Virtual for expense ratio
reportSchema.virtual('expenseRatio').get(function() {
  if (this.summary.totalIncome === 0) return 0;
  return (this.summary.totalExpense / this.summary.totalIncome) * 100;
});

// Indexes for better query performance
reportSchema.index({ user: 1, period: 1 });
reportSchema.index({ user: 1, startDate: -1 });
reportSchema.index({ generatedAt: -1 });

// Pre-save middleware to calculate summary
reportSchema.pre('save', function(next) {
  // Calculate net balance
  this.summary.netBalance = this.summary.totalIncome - this.summary.totalExpense;
  
  // Calculate averages
  if (this.summary.transactionCount > 0) {
    this.summary.averageIncome = this.summary.totalIncome / this.summary.transactionCount;
    this.summary.averageExpense = this.summary.totalExpense / this.summary.transactionCount;
  }
  
  // Calculate percentages for category breakdown
  const total = this.summary.totalIncome + this.summary.totalExpense;
  if (total > 0) {
    this.categoryBreakdown.forEach(category => {
      category.percentage = (category.amount / total) * 100;
    });
  }
  
  next();
});

// Static method to generate report for user
reportSchema.statics.generateReport = async function(userId, startDate, endDate, period = 'custom') {
  const Transaction = mongoose.model('Transaction');
  
  try {
    // Get transactions in date range
    const transactions = await Transaction.find({
      user: userId,
      date: { $gte: startDate, $lte: endDate },
      status: 'completed'
    }).populate('category', 'name icon color type');

    // Calculate summary
    const summary = {
      totalIncome: 0,
      totalExpense: 0,
      transactionCount: transactions.length
    };

    const categoryMap = new Map();

    transactions.forEach(transaction => {
      if (transaction.type === 'income') {
        summary.totalIncome += transaction.amount;
      } else {
        summary.totalExpense += transaction.amount;
      }

      // Category breakdown
      const categoryId = transaction.category._id.toString();
      if (!categoryMap.has(categoryId)) {
        categoryMap.set(categoryId, {
          category: transaction.category._id,
          amount: 0,
          count: 0
        });
      }
      
      const categoryData = categoryMap.get(categoryId);
      categoryData.amount += transaction.amount;
      categoryData.count += 1;
    });

    // Get top transactions (highest amounts)
    const topTransactions = transactions
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 10)
      .map(t => t._id);

    // Generate insights
    const insights = generateInsights(summary, transactions);

    // Create report
    const report = new this({
      user: userId,
      period,
      startDate,
      endDate,
      summary,
      categoryBreakdown: Array.from(categoryMap.values()),
      topTransactions,
      insights
    });

    return await report.save();
  } catch (error) {
    throw new Error(`Failed to generate report: ${error.message}`);
  }
};

// Static method to get user's latest report
reportSchema.statics.getLatestReport = function(userId, period = 'monthly') {
  return this.findOne({ user: userId, period })
    .sort({ startDate: -1 })
    .populate('categoryBreakdown.category', 'name icon color')
    .populate('topTransactions');
};

// Static method to get report history
reportSchema.statics.getReportHistory = function(userId, limit = 10) {
  return this.find({ user: userId })
    .sort({ startDate: -1 })
    .limit(limit)
    .populate('categoryBreakdown.category', 'name icon color');
};

// Helper function to generate insights
function generateInsights(summary, transactions) {
  const insights = [];

  // Spending pattern insight
  if (summary.totalExpense > 0) {
    const avgDailyExpense = summary.totalExpense / 30; // Assuming 30 days
    if (avgDailyExpense > 100) {
      insights.push({
        type: 'spending_pattern',
        title: 'High Daily Spending',
        description: `Your average daily expense is $${avgDailyExpense.toFixed(2)}`,
        severity: 'warning',
        data: { averageDailyExpense: avgDailyExpense }
      });
    }
  }

  // Savings goal insight
  if (summary.totalIncome > 0) {
    const savingsRate = ((summary.totalIncome - summary.totalExpense) / summary.totalIncome) * 100;
    if (savingsRate < 10) {
      insights.push({
        type: 'savings_goal',
        title: 'Low Savings Rate',
        description: `Your savings rate is ${savingsRate.toFixed(1)}%. Consider increasing your savings.`,
        severity: 'warning',
        data: { savingsRate }
      });
    } else if (savingsRate > 20) {
      insights.push({
        type: 'savings_goal',
        title: 'Excellent Savings Rate',
        description: `Great job! Your savings rate is ${savingsRate.toFixed(1)}%`,
        severity: 'info',
        data: { savingsRate }
      });
    }
  }

  // Category alert
  const categorySpending = {};
  transactions.forEach(t => {
    if (t.type === 'expense') {
      const categoryName = t.category.name;
      categorySpending[categoryName] = (categorySpending[categoryName] || 0) + t.amount;
    }
  });

  const topCategory = Object.entries(categorySpending)
    .sort(([,a], [,b]) => b - a)[0];

  if (topCategory && topCategory[1] > summary.totalExpense * 0.4) {
    insights.push({
      type: 'category_alert',
      title: 'High Category Spending',
      description: `You spent ${((topCategory[1] / summary.totalExpense) * 100).toFixed(1)}% of your expenses on ${topCategory[0]}`,
      severity: 'warning',
      data: { category: topCategory[0], percentage: (topCategory[1] / summary.totalExpense) * 100 }
    });
  }

  return insights;
}

module.exports = mongoose.model('Report', reportSchema);
